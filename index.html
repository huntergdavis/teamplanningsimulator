<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TPS Reports - Contract Sprints & Ramp-Up</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone@7/babel.min.js"></script>

  <style>
    body {
      margin: 0; 
      padding: 0;
      font-family: sans-serif;
      color: #333;
    }
    .container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      height: 100vh;
      overflow: hidden;
    }
    .left-panel {
      padding: 1rem;
      background: #f3f4f6;
      overflow-y: auto;
    }
    .list-item {
      background: #4299e1;
      color: #fff;
      margin: 0.4rem 0;
      padding: 0.6rem 0.8rem;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: background 0.2s;
    }
    .list-item.year {
      background: #2c5282;
    }
    .list-item.quarter {
      background: #2b6cb0;
    }
    .list-item.sprint {
      background: #4299e1;
    }
    .assignments {
      margin-left: 1rem;
      display: flex;
      flex-wrap: wrap;
    }
    .assignments .ramp {
      color: #d53f8c;
      font-weight: bold;
      margin-left: 3px;
    }
    .right-panel {
      border-left: 2px solid #ddd;
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }
    .roster {
      padding: 1rem;
      background: #fff;
      flex: 0 0 auto;
      border-bottom: 2px solid #ddd;
    }
    .roster-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .roster-header button {
      padding: 0.4rem 0.8rem;
      background: #3182ce;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .roster-items {
      margin-top: 1rem;
    }
    .roster-item {
      background: #edf2f7;
      margin: 0.25rem 0;
      padding: 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      transition: background 0.2s;
    }
    .roster-item:hover {
      background: #e2e8f0;
    }
    .report-section {
      padding: 1rem;
      flex: 1 1 auto;
      overflow-y: auto;
    }
    .report {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #aaa;
    }
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">

/** 
 * We assume 26 sprints/year => cost per sprint = (salary*overhead)/26 
 * Each sprint = 2 weeks => points = role.pointsPerWeek * 2 (or half if ramping).
**/
const YEAR_SPRINTS = 26;
const SPRINT_WEEKS = 2;

const lineItems = [
  { id: 'year-2025', type: 'year',    name: '2025', roles: [], events: [] },
  { id: 'q1',        type: 'quarter', name: 'Q1',   roles: [], events: [] },
  { id: 'q1s1', type: 'sprint', name: 'Q1S1', roles: [], events: [] },
  { id: 'q1s2', type: 'sprint', name: 'Q1S2', roles: [], events: [] },
  { id: 'q1s3', type: 'sprint', name: 'Q1S3', roles: [], events: [] },
  { id: 'q1s4', type: 'sprint', name: 'Q1S4', roles: [], events: [] },
  { id: 'q1s5', type: 'sprint', name: 'Q1S5', roles: [], events: [] },
  { id: 'q1s6', type: 'sprint', name: 'Q1S6', roles: [], events: [] },

  { id: 'q2',   type: 'quarter', name: 'Q2', roles: [], events: [] },
  { id: 'q2s1', type: 'sprint',  name: 'Q2S1', roles: [], events: [] },
  { id: 'q2s2', type: 'sprint',  name: 'Q2S2', roles: [], events: [] },
  { id: 'q2s3', type: 'sprint',  name: 'Q2S3', roles: [], events: [] },
  { id: 'q2s4', type: 'sprint',  name: 'Q2S4', roles: [], events: [] },
  { id: 'q2s5', type: 'sprint',  name: 'Q2S5', roles: [], events: [] },
  { id: 'q2s6', type: 'sprint',  name: 'Q2S6', roles: [], events: [] },

  { id: 'q3',   type: 'quarter', name: 'Q3', roles: [], events: [] },
  { id: 'q3s1', type: 'sprint',  name: 'Q3S1', roles: [], events: [] },
  { id: 'q3s2', type: 'sprint',  name: 'Q3S2', roles: [], events: [] },
  { id: 'q3s3', type: 'sprint',  name: 'Q3S3', roles: [], events: [] },
  { id: 'q3s4', type: 'sprint',  name: 'Q3S4', roles: [], events: [] },
  { id: 'q3s5', type: 'sprint',  name: 'Q3S5', roles: [], events: [] },
  { id: 'q3s6', type: 'sprint',  name: 'Q3S6', roles: [], events: [] },

  { id: 'q4',   type: 'quarter', name: 'Q4', roles: [], events: [] },
  { id: 'q4s1', type: 'sprint',  name: 'Q4S1', roles: [], events: [] },
  { id: 'q4s2', type: 'sprint',  name: 'Q4S2', roles: [], events: [] },
  { id: 'q4s3', type: 'sprint',  name: 'Q4S3', roles: [], events: [] },
  { id: 'q4s4', type: 'sprint',  name: 'Q4S4', roles: [], events: [] },
  { id: 'q4s5', type: 'sprint',  name: 'Q4S5', roles: [], events: [] },
  { id: 'q4s6', type: 'sprint',  name: 'Q4S6', roles: [], events: [] },
];

/**
 * Helper: find all sprint indices if user clicks "year", or a quarter, or a single sprint.
 */
function getSprintIndices(itemIndex) {
  const item = lineItems[itemIndex];
  if (item.type === 'year') {
    // all sprints => 2..28
    return Array.from({ length: 27 }, (_, i) => i+2); 
  } else if (item.type === 'quarter') {
    // gather next sprints until next quarter or end
    return gatherQuarterSprints(itemIndex);
  } else {
    // single sprint => just that index
    return [itemIndex];
  }
}
function gatherQuarterSprints(qIndex) {
  let out = [];
  let i = qIndex+1;
  while (i<lineItems.length && lineItems[i].type==='sprint') {
    out.push(i);
    i++;
  }
  return out;
}

function TPSReportsApp() {
  const [items, setItems] = React.useState(lineItems);
  const [roles, setRoles] = React.useState([]);
  const [events, setEvents] = React.useState([]);
  const [reportTargetId, setReportTargetId] = React.useState(null);

  /**
   * Create a new role or event.
   */
  function handleAddNewItem() {
    const kind = prompt('Add "role" or "event"?');
    if (!kind) return;

    if (kind.toLowerCase()==='role') {
      const name = prompt('Role name?');
      const fte = prompt('Is this FTE? (yes/no)');
      const salaryStr = prompt('Yearly Salary?');
      const pointsStr = prompt('Points delivered per week?');
      const specialty = prompt('Specialty? e.g. "UI"');
      const rampStr = prompt('How many sprints to ramp up? (0..6)');

      let isFte = (fte?.toLowerCase()==='yes');
      let contractLen=null;
      if (!isFte) {
        const cStr = prompt('How many total sprints for this contract?');
        if (cStr) {
          const cNum = parseInt(cStr,10);
          if (!isNaN(cNum) && cNum>0) contractLen=cNum;
        }
      }

      const newRole={
        id: 'role-'+Date.now(),
        name: name||'Untitled Role',
        fte: isFte,
        overheadMultiplier: isFte?1.17:1,
        salary: Number(salaryStr)||0,
        pointsPerWeek: Number(pointsStr)||0,
        specialty: specialty||'generalist',
        rampUpSprints: parseInt(rampStr,10)||0,
        contractSprints: contractLen, // if null => unlimited
      };
      setRoles(prev=> [...prev, newRole]);

    } else if (kind.toLowerCase()==='event') {
      const name = prompt('Event name?');
      const impact = prompt('Impact to shift points? (positive/negative)?');
      const repeat = prompt('Repeat forever? (yes/no)');
      const newEvent={
        id: 'event-'+Date.now(),
        name: name||'Untitled Event',
        impactPoints: Number(impact)||0,
        repeatForever: (repeat?.toLowerCase()==='yes'),
      };
      setEvents(prev=>[...prev,newEvent]);

    } else {
      alert('Invalid type.');
    }
  }

  /**
   * Add a role (could be FTE or contract) from chosen line item onward.
   * If contract => only up to contractSprints sprints.
   * Mark each line item whether it's ramping or not, based on usageSoFar < rampUpSprints.
   */
  function handleRoleClick(role) {
    const qtyStr = prompt(`How many of "${role.name}" do you want to add?`, '1');
    if (!qtyStr) return;
    const qty = parseInt(qtyStr,10);
    if (isNaN(qty) || qty<=0) {
      alert('Invalid #');
      return;
    }

    const tgt = prompt('Which line item to start on? (e.g. "q3s4" or "year-2025")');
    if (!tgt) return;
    const startIndex= items.findIndex(x=> x.id===tgt);
    if (startIndex<0){
      alert('No such line item');
      return;
    }

    // We'll do usageSoFar for each of the "qty" clones, so each clone has its own usage count.
    // That might be overkill if you want them all the same usage, but let's do it anyway for correctness.
    // Minimal approach: we do a for-loop from 0..(qty-1) => each clone has usageSoFar=0, then we walk line items from startIndex onward. 
    // If contract => we only do up to contractSprints sprints. 
    // Each time we add them to a line item, we check usageSoFar < rampUp => isRamping=true else false, usageSoFar++.
    const newArr = [...items];

    for (let c=0; c<qty; c++){
      let usageSoFar=0; 
      let sCount= role.fte? Infinity : (role.contractSprints||0); // Infinity if FTE
      let lineCount=0; // how many lines we've assigned so far

      for (let i=startIndex; i<newArr.length; i++){
        const lineItem=newArr[i];
        // skip if not a "sprint"
        if (lineItem.type!=='sprint' && lineItem.type!=='year' && lineItem.type!=='quarter') {
          continue;
        }
        if (!role.fte) {
          // if contract => stop if lineCount >= sCount
          if (lineCount>= sCount) break;
        }
        const isRamping= (usageSoFar<role.rampUpSprints);

        // add to roles array
        const newRoleObj={
          roleId: role.id,
          isRamping,
        };
        // push
        const oldRoles=[...lineItem.roles];
        oldRoles.push(newRoleObj);
        newArr[i]={ ...lineItem, roles: oldRoles };

        usageSoFar++;
        lineCount++;
      }
    }

    setItems(newArr);
  }

  /**
   * Add an event from line item onward (repeatForever is not fully used here, but let's ignore).
   */
  function handleEventClick(ev) {
    const qtyStr=prompt(`How many of "${ev.name}" to add?`,'1');
    if (!qtyStr) return;
    const qty=parseInt(qtyStr,10);
    if (isNaN(qty)||qty<=0) {
      alert('Invalid #');
      return;
    }

    const tgt=prompt('Which line item to start on?');
    if (!tgt) return;
    const startIndex= items.findIndex(x=> x.id===tgt);
    if (startIndex<0){
      alert('No such line item');
      return;
    }

    const newArr=[...items];
    for (let c=0; c<qty; c++){
      for (let i=startIndex; i<newArr.length; i++){
        const lineItem=newArr[i];
        // skip if not sprint/year/quarter
        if (lineItem.type!=='sprint' && lineItem.type!=='year' && lineItem.type!=='quarter') continue;

        const oldE=[...lineItem.events];
        oldE.push({ eventId: ev.id });
        newArr[i]={ ...lineItem, events: oldE };
      }
    }

    setItems(newArr);
  }

  function handleGenerateReport(itemId) {
    setReportTargetId(itemId);
  }

  /**
   * For the aggregator:
   * We'll gather the sprints that item covers, sum up cost/points, respecting `isRamping` for each role in each sprint. 
   * cost => (role.salary*role.overhead)/26
   * if isRamping => half points => role.pointsPerWeek*2 *0.5
   * else => full
   */
  function renderReport() {
    if (!reportTargetId) return null;
    const idx= items.findIndex(x=> x.id===reportTargetId);
    if (idx<0) return null;

    const item= items[idx];
    const sprintIndices= getSprintIndices(idx);

    let totalCost=0, totalPoints=0;
    let breakdownBySpecialty={};
    let usedRoles=[];
    let usedEvents=[];

    sprintIndices.forEach((si)=>{
      const sItem= items[si];
      // roles
      sItem.roles.forEach((rObj)=>{
        const rData= roles.find(rr=> rr.id===rObj.roleId);
        if (!rData) return;

        // cost
        const overhead = rData.salary*rData.overheadMultiplier;
        const costPerSprint = overhead / YEAR_SPRINTS;
        totalCost += costPerSprint;

        // points
        const weeklyPts= rData.pointsPerWeek*SPRINT_WEEKS;
        const finalPts = rObj.isRamping? (weeklyPts*0.5) : weeklyPts;
        totalPoints+= finalPts;

        // track specialty
        if (!breakdownBySpecialty[rData.specialty]){
          breakdownBySpecialty[rData.specialty]={ cost:0, points:0 };
        }
        breakdownBySpecialty[rData.specialty].cost+= costPerSprint;
        breakdownBySpecialty[rData.specialty].points+= finalPts;

        usedRoles.push({ rData, isRamping: rObj.isRamping });
      });
      // events
      sItem.events.forEach((eObj)=>{
        const eData= events.find(ee=> ee.id=== eObj.eventId);
        if (!eData) return;
        totalPoints+= eData.impactPoints;
        usedEvents.push(eData);
      });
    });

    // distinct
    let distinctRoles=[];
    const seenR= new Set();
    usedRoles.forEach(ur=>{
      if (!seenR.has(ur.rData.id)) {
        distinctRoles.push(ur);
        seenR.add(ur.rData.id);
      }
    });
    const distinctEvents= Array.from(new Set(usedEvents));

    const totalBoulders= totalPoints/40;
    const costPerPoint= (totalPoints>0)?(totalCost/ totalPoints):0;

    // if a role had ANY ramping => star
    const rampedRoleIds = new Set( usedRoles.filter(u=> u.isRamping).map(u=> u.rData.id) );

    return (
      <div className="report">
        <h2>Report for {item.name} ({item.type})</h2>
        <p><strong>Sprints in scope:</strong> {sprintIndices.length}</p>
        <p><strong>Total Cost:</strong> ${Math.round(totalCost).toLocaleString()}</p>
        <p><strong>Total Points:</strong> {Math.round(totalPoints)}</p>
        <p><strong>Boulders (40 pts):</strong> {totalBoulders.toFixed(2)}</p>
        <p><strong>Cost per Point:</strong> ${costPerPoint.toFixed(2)}</p>

        <h3>By Specialty</h3>
        {Object.keys(breakdownBySpecialty).map((spec)=>{
          const data= breakdownBySpecialty[spec];
          const cPerP= (data.points>0)?(data.cost/data.points):0;
          return (
            <div key={spec}>
              <strong>{spec}:</strong> ${cPerP.toFixed(2)} / point
            </div>
          );
        })}

        <h3>Roles in scope</h3>
        <ul>
          {distinctRoles.map((ur)=>{
            const star= rampedRoleIds.has(ur.rData.id)? '*':'';
            return (
              <li key={ur.rData.id}>
                {ur.rData.name}{star} ({ur.rData.specialty}) 
                - Salary: ${ur.rData.salary.toLocaleString()}
                {ur.rData.fte? ' (FTE)': ` (Contract: up to ${ur.rData.contractSprints} sprints)`}
                , rampUp={ur.rData.rampUpSprints} 
              </li>
            );
          })}
        </ul>

        <h3>Events in scope</h3>
        <ul>
          {distinctEvents.map(e=> (
            <li key={e.id}>{e.name} (impact={e.impactPoints})</li>
          ))}
        </ul>
      </div>
    );
  }

  /**
   * Rendering the left panel: each line item => show role letters, but if isRamping => letter+*
   */
  function renderLineItem(li, idx) {
    let cssClass='sprint';
    if (li.type==='year') cssClass='year';
    else if (li.type==='quarter') cssClass='quarter';

    // gather a small set of { letter, isRamping } for each role
    const roleIcons= li.roles.map((ro, i2)=>{
      const rData= roles.find(rr=> rr.id=== ro.roleId);
      if (!rData) return null;
      const letter=rData.name.charAt(0).toUpperCase();
      return (
        <span key={'r'+i2}>
          {letter}
          {ro.isRamping && <span className="ramp">*</span>}
        </span>
      );
    }).filter(Boolean);

    const eventIcons= li.events.map((eo,i2)=>{
      const eData= events.find(e=> e.id===eo.eventId);
      if (!eData) return null;
      const letter= eData.name.charAt(0).toUpperCase();
      return (<span key={'e'+i2}>{letter}</span>);
    }).filter(Boolean);

    const combined=[...roleIcons, ...eventIcons];

    return (
      <div 
        key={li.id}
        className={`list-item ${cssClass}`}
        onClick={()=> handleGenerateReport(li.id)}
      >
        {li.name}
        {combined.length>0 && (
          <div className="assignments">
            {combined}
          </div>
        )}
      </div>
    );
  }

  return (
    <div className="container">
      <div className="left-panel">
        {items.map((li, idx)=> renderLineItem(li, idx))}
      </div>
      <div className="right-panel">
        <div className="roster">
          <div className="roster-header">
            <h3>Roster</h3>
            <button onClick={handleAddNewItem}>+</button>
          </div>
          <div className="roster-items">
            <h4>Roles</h4>
            {roles.map(r=> (
              <div 
                key={r.id}
                className="roster-item"
                onClick={()=> handleRoleClick(r)}
              >
                {r.name} {r.fte? '(FTE)':'(Contract)'} rampUp={r.rampUpSprints}
              </div>
            ))}
            <h4>Events</h4>
            {events.map(e=>(
              <div
                key={e.id}
                className="roster-item"
                onClick={()=> handleEventClick(e)}
              >
                {e.name} (impact={e.impactPoints})
              </div>
            ))}
          </div>
        </div>
        <div className="report-section">
          {renderReport()}
        </div>
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<TPSReportsApp />);
</script>
</body>
</html>
